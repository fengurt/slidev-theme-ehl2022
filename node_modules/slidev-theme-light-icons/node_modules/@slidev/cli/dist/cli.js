"use strict"; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkX63TFDKCjs = require('./chunk-X63TFDKC.js');
require('./chunk-CWV5AMYB.js');





var _chunkGELV3XCVjs = require('./chunk-GELV3XCV.js');


var _chunkVG7QAVECjs = require('./chunk-VG7QAVEC.js');

// node/cli.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _http = require('http'); var _http2 = _interopRequireDefault(_http);
var _os = require('os'); var _os2 = _interopRequireDefault(_os);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _yargs = require('yargs'); var _yargs2 = _interopRequireDefault(_yargs);
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault(_prompts);
var _kolorist = require('kolorist');





var _fs = require('@slidev/parser/fs');

// package.json
var version = "0.7.4";

// node/cli.ts
var cli = _yargs2.default.scriptName("slidev").usage("$0 [args]").version(version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command("* [entry]", "Start a local server for Slidev", (args) => commonOptions(args).option("port", {
  alias: "p",
  type: "number",
  describe: "port"
}).option("open", {
  alias: "o",
  default: false,
  type: "boolean",
  describe: "open in browser"
}).option("remote", {
  default: false,
  type: "boolean",
  describe: "listen public host and enable remote control"
}).option("log", {
  default: "warn",
  type: "string",
  choices: ["error", "warn", "info", "silent"],
  describe: "log level"
}).strict().help(), async ({entry, theme, port, open, log, remote}) => {
  if (!_fsextra2.default.existsSync(entry) && !entry.endsWith(".md"))
    entry = `${entry}.md`;
  if (!_fsextra2.default.existsSync(entry)) {
    const {create} = await _prompts2.default.call(void 0, {
      name: "create",
      type: "confirm",
      initial: "Y",
      message: `Entry file ${_kolorist.yellow.call(void 0, `"${entry}"`)} does not exist, do you want to create it?`
    });
    if (create)
      await _fsextra2.default.copyFile(_path2.default.resolve(__dirname, "../template.md"), entry);
    else
      process.exit(0);
  }
  let server;
  async function initServer() {
    if (server)
      await server.close();
    const options = await _chunkGELV3XCVjs.resolveOptions.call(void 0, {entry, theme}, "dev");
    port = port || await findFreePort(3030);
    server = await _chunkX63TFDKCjs.createServer.call(void 0, options, {
      onDataReload(newData, data) {
        if (!theme && _chunkGELV3XCVjs.resolveThemeName.call(void 0, newData.config.theme) !== _chunkGELV3XCVjs.resolveThemeName.call(void 0, data.config.theme)) {
          console.log(_kolorist.yellow.call(void 0, "\n  restarting on theme change\n"));
          initServer();
        } else if (newData.config.monaco !== data.config.monaco || newData.config.highlighter !== data.config.highlighter) {
          console.log(_kolorist.yellow.call(void 0, "\n  restarting on config change\n"));
          initServer();
        }
      }
    }, {
      server: {
        port,
        open,
        host: remote ? "0.0.0.0" : "localhost"
      },
      logLevel: log
    });
    await server.listen();
    printInfo(options, port, remote);
  }
  initServer();
});
cli.command("build [entry]", "Build hostable SPA", (args) => commonOptions(args).option("watch", {
  alias: "w",
  default: false,
  describe: "build watch"
}).option("out", {
  alias: "o",
  type: "string",
  default: "dist",
  describe: "output dir"
}).option("base", {
  type: "string",
  describe: "output base"
}).option("download", {
  alias: "d",
  type: "boolean",
  describe: "allow download as PDF"
}).strict().help(), async ({entry, theme, watch, base, download, out}) => {
  const {build} = await Promise.resolve().then(() => _chunkVG7QAVECjs.__toModule.call(void 0, require("./build-CVCFHMSL.js")));
  const options = await _chunkGELV3XCVjs.resolveOptions.call(void 0, {entry, theme}, "build");
  if (download && !options.data.config.download)
    options.data.config.download = download;
  printInfo(options);
  await build(options, {}, {
    base,
    build: {
      watch: watch ? {} : void 0,
      outDir: out
    }
  });
});
cli.command("format [entry]", "Format the markdown file", (args) => commonOptions(args).strict().help(), async ({entry}) => {
  const data = await _fs.load.call(void 0, entry);
  _fs.prettify.call(void 0, data);
  await _fs.save.call(void 0, data);
});
cli.command("theme [subcommand]", "Theme related operations", (command) => {
  return command.command("eject", "Eject current theme into local file system", (args) => commonOptions(args).option("dir", {
    type: "string",
    default: "theme"
  }), async ({entry, dir, theme: themeInput}) => {
    const data = await _fs.load.call(void 0, entry);
    const theme = _chunkGELV3XCVjs.resolveThemeName.call(void 0, themeInput || data.config.theme);
    if (theme === "none") {
      console.error('Can not eject theme "none"');
      process.exit(1);
    }
    if (_chunkGELV3XCVjs.isRelative.call(void 0, theme)) {
      console.error("Theme is already ejected");
      process.exit(1);
    }
    const roots = _chunkGELV3XCVjs.getThemeRoots.call(void 0, theme, entry);
    if (!roots.length) {
      console.error(`Does not found theme "${theme}"`);
      process.exit(1);
    }
    const root = roots[0];
    await _fsextra2.default.copy(root, _path2.default.resolve(dir), {
      filter: (i) => !/node_modules|.git/.test(_path2.default.relative(root, i))
    });
    const dirPath = `./${dir}`;
    data.slides[0].frontmatter.theme = dirPath;
    data.slides[0].raw = "";
    await _fs.save.call(void 0, data);
    console.log(`Theme "${theme}" ejected successfully to "${dirPath}"`);
  });
}, () => {
  cli.showHelp();
  process.exit(1);
});
cli.command("export [entry]", "Export slides to PDF", (args) => commonOptions(args).option("output", {
  type: "string",
  describe: "path to the the port output"
}).option("format", {
  default: "pdf",
  type: "string",
  choices: ["pdf", "png"],
  describe: "output format"
}).option("timeout", {
  default: 100,
  type: "number",
  describe: "timeout for rendering each page"
}).option("range", {
  type: "string",
  describe: 'page ranges to export, for example "1,4-5,6"'
}).strict().help(), async ({
  entry,
  theme,
  output,
  format,
  timeout,
  range
}) => {
  output = output || `${_path2.default.basename(entry, ".md")}-export`;
  process.env.NODE_ENV = "production";
  const {exportSlides} = await Promise.resolve().then(() => _chunkVG7QAVECjs.__toModule.call(void 0, require("./export-6G26VWJY.js")));
  const port = await findFreePort(12445);
  const options = await _chunkGELV3XCVjs.resolveOptions.call(void 0, {entry, theme}, "build");
  const server = await _chunkX63TFDKCjs.createServer.call(void 0, options, {}, {
    server: {port},
    logLevel: "error",
    clearScreen: false
  });
  await server.listen(port);
  printInfo(options);
  _fs.filterDisabled.call(void 0, options.data);
  output = await exportSlides({
    port,
    total: options.data.slides.length,
    range,
    format,
    output,
    timeout
  });
  console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${output}
`);
  server.close();
  process.exit(0);
});
cli.help().parse();
function commonOptions(args) {
  return args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("theme", {
    alias: "t",
    type: "string",
    describe: "overide theme"
  });
}
function printInfo(options, port, remote) {
  console.log();
  console.log();
  console.log(`  ${_kolorist.cyan.call(void 0, "\u25CF") + _kolorist.blue.call(void 0, "\u25A0") + _kolorist.yellow.call(void 0, "\u25B2")}`);
  console.log(`${_kolorist.bold.call(void 0, "  Slidev")}  ${_kolorist.blue.call(void 0, `v${version}`)}`);
  console.log();
  console.log(_kolorist.dim.call(void 0, "  theme   ") + (options.theme ? _kolorist.green.call(void 0, options.theme) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  entry   ") + _kolorist.dim.call(void 0, _path2.default.dirname(options.entry) + _path2.default.sep) + _path2.default.basename(options.entry));
  if (port) {
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  slide show     ")} > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/`)}`);
    console.log(`${_kolorist.dim.call(void 0, "  presenter mode ")} > ${_kolorist.blue.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/presenter`)}`);
    if (remote) {
      Object.values(_os2.default.networkInterfaces()).forEach((v) => (v || []).filter((details) => details.family === "IPv4" && !details.address.includes("127.0.0.1")).forEach(({address}) => {
        console.log(`${_kolorist.dim.call(void 0, "  remote control ")} > ${_kolorist.blue.call(void 0, `http://${address}:${port}/presenter`)}`);
      }));
    } else {
      console.log(`${_kolorist.dim.call(void 0, "  remote control ")} > ${_kolorist.dim.call(void 0, "pass --remote to enable")}`);
    }
  }
  console.log();
  console.log();
}
function isPortFree(port) {
  return new Promise((resolve) => {
    const server = _http2.default.createServer().listen(port, () => {
      server.close();
      resolve(true);
    }).on("error", () => {
      resolve(false);
    });
  });
}
async function findFreePort(start) {
  if (await isPortFree(start))
    return start;
  return findFreePort(start + 1);
}
